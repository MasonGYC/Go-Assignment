package main

import (
	"fmt"
	"math/rand"
	"time"
)

type Node struct {
	ID        int
	Election  chan int
	Alive     bool
	Leader    int
	HigherIDs []int
}

func NewNode(id int, higherIDs []int) *Node {
	return &Node{
		ID:        id,
		Election:  make(chan int),
		Alive:     true,
		Leader:    -1,
		HigherIDs: higherIDs,
	}
}

func (n *Node) StartElection() {
	if !n.Alive {
		return
	}

	fmt.Printf("Node %d: Starting election\n", n.ID)

	// Notify higher ID nodes
	for _, higherID := range n.HigherIDs {
		go func(id int) {
			select {
			case n.Election <- id:
				// Node with higher ID is still alive
				fmt.Printf("Node %d: Sent election message to %d\n", n.ID, id)
			default:
				// Node with higher ID did not respond
				fmt.Printf("Node %d: Did not receive response from %d\n", n.ID, id)
				n.StartElection()
			}
		}(higherID)
	}

	// Assume leadership if no one with higher ID responds
	n.Leader = n.ID
	fmt.Printf("Node %d: Elected as leader\n", n.ID)

	// Notify lower ID nodes of election result
	for _, higherID := range n.HigherIDs {
		go func(id int) {
			if id != n.ID {
				n.Election <- -1 // Inform lower ID nodes of leader
			}
		}(higherID)
	}
}

func (n *Node) ReceiveElection(id int) {
	if !n.Alive {
		return
	}

	if id > n.ID {
		fmt.Printf("Node %d: Received election message from %d\n", n.ID, id)
		n.StartElection()
	} else {
		fmt.Printf("Node %d: Received election message from %d, ignoring\n", n.ID, id)
	}
}

func (n *Node) ReceiveLeaderNotification(id int) {
	if !n.Alive {
		return
	}

	if id != n.ID {
		fmt.Printf("Node %d: Received leader notification from %d, setting leader\n", n.ID, id)
		n.Leader = id
	}
}

func (n *Node) Fail() {
	fmt.Printf("Node %d: Failed\n", n.ID)
	n.Alive = false
}

func main() {
	rand.Seed(time.Now().UnixNano())

	// Create nodes with unique IDs
	nodes := make([]*Node, 5)
	for i := 0; i < len(nodes); i++ {
		higherIDs := make([]int, 0)
		for j := i + 1; j < len(nodes); j++ {
			higherIDs = append(higherIDs, j)
		}
		nodes[i] = NewNode(i, higherIDs)
	}

	// Start an election by randomly selecting a node
	randomNode := nodes[rand.Intn(len(nodes))]
	randomNode.StartElection()

	// Simulate node failures
	go func() {
		time.Sleep(3 * time.Second)
		randomNode.Fail()
	}()

	// Simulate message passing between nodes
	for _, node := range nodes {
		go func(n *Node) {
			for {
				select {
				case id := <-n.Election:
					n.ReceiveElection(id)
				}
			}
		}(node)
	}

	// Check leader status
	for _, node := range nodes {
		go func(n *Node) {
			for {
				time.Sleep(1 * time.Second)
				fmt.Printf("Node %d: Current leader is %d\n", n.ID, n.Leader)
			}
		}(node)
	}

	// Keep the program running
	select {}
}
